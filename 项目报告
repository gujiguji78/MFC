《高级程序设计》课程项目二
简易绘图板（MFCPaint01）设计与实现报告
一、项目概述
1.1 项目背景

随着图形用户界面（GUI）应用的广泛使用，图形绘制类程序在工程软件、教学软件以及日常办公软件中具有重要地位。
本项目作为《高级程序设计》课程的综合实践内容，要求基于 Windows 平台与 MFC 框架，设计并实现一款简易绘图板程序，通过实际编码过程加深对 面向对象设计思想、MFC Doc/View 架构以及常见设计模式 的理解与应用。

1.2 项目目标

本项目的主要目标包括：

熟悉 MFC 应用程序的基本结构与消息响应机制；

掌握 GDI 绘图的基本方法，实现多种图形的绘制；

运用工厂模式、命令模式和策略模式，实现良好的系统架构；

实现绘图操作的撤销与重做功能；

提高程序的可维护性、可扩展性与工程规范性。

二、需求分析
2.1 功能性需求

根据项目任务要求，系统需实现以下功能：

基本绘图功能
支持直线、矩形、椭圆以及自由曲线等多种图形的绘制；

交互绘制
支持“鼠标按下—拖动—松开”的交互方式，并在绘制过程中显示图形预览；

属性设置
支持设置图形颜色与线宽；

撤销与重做
支持对绘图操作进行撤销（Undo）与重做（Redo）；

文件存储
支持绘图内容的保存与再次加载。

2.2 非功能性需求

可维护性：系统结构清晰，模块职责明确；

可扩展性：便于新增图形类型或扩展绘制方式；

性能要求：绘制过程流畅，无明显卡顿；

安全性：避免资源泄漏，保证程序稳定运行。

三、系统总体设计
3.1 架构设计

本项目采用 MFC Document/View（文档/视图）架构，并结合 MVC 设计思想进行组织：

Model（数据模型）
由 CMFCPaint01Doc 类承担，负责存储所有图形对象，并完成数据的序列化与反序列化；

View（视图）
由 MFCpaint01View 类负责，处理用户输入并完成图形绘制；

Controller（控制逻辑）
通过命令模式实现，主要由 Command、AddShapeCommand 与 ShapeManager 共同完成。

该架构实现了数据、界面与操作逻辑的有效分离，降低了模块之间的耦合度。

四、核心类与模块设计
4.1 图形抽象层设计（Shape）

Shape 类作为所有图形对象的抽象基类，定义了统一的接口，包括：

Draw(CDC* pDC)：完成最终绘制；

DrawPreview(CDC* pDC)：在鼠标拖动过程中绘制预览效果；

Clone()：支持图形对象复制；

Serialize(CArchive& ar)：支持图形对象的序列化。

所有具体图形类均继承自 Shape，包括：

LineShape：直线图形；

RectShape：矩形图形；

EllipseShape：椭圆图形；

FreehandShape：自由曲线图形。

这种设计体现了策略模式思想，不同图形通过各自的 Draw 实现不同的绘制策略。

4.2 工厂模式设计（ShapeFactory）

ShapeFactory 类负责图形对象的创建，提供统一的创建接口：

根据图形类型创建对应的 Shape 子类对象；

在反序列化过程中，根据文件中存储的类型信息动态构造图形对象。

通过工厂模式，将图形对象的创建逻辑与使用逻辑解耦，使系统在新增图形类型时只需扩展工厂类即可，无需修改原有视图代码，提高了系统的可扩展性。

4.3 命令模式设计（Command）

为实现撤销与重做功能，项目采用 命令模式 对绘图操作进行封装。

Command：抽象命令基类，定义 Execute 与 Unexecute 接口；

AddShapeCommand：具体命令类，封装“添加图形”的操作；

ShapeManager：命令管理器，内部维护撤销栈与重做栈。

用户的每一次绘图操作都会被封装为一个命令对象，执行时压入撤销栈；撤销操作通过调用命令的 Unexecute 实现，重做操作则重新执行对应命令。

该设计使得操作具备良好的可逆性，同时也便于后续扩展更多类型的操作命令。

五、关键功能实现
5.1 绘图与预览机制

在绘制过程中，程序通过 DrawPreview 方法实时显示图形轮廓，使用户在鼠标拖动过程中即可看到绘制效果，提升了交互体验。

5.2 撤销与重做功能

系统采用双栈结构分别管理撤销与重做操作：

执行新命令时，清空重做栈；

撤销操作将命令从撤销栈移至重做栈；

重做操作将命令重新执行并返回撤销栈。

该机制逻辑清晰，运行稳定。

5.3 文件存储与序列化

通过重写 CMFCPaint01Doc::Serialize 方法，结合 MFC 的 CArchive 类，实现图形对象的保存与加载。
每个图形对象负责自身数据的序列化，保证了数据存储的完整性与一致性。

六、非功能需求实现分析
6.1 可维护性

通过抽象基类与设计模式的应用，系统模块职责明确，代码结构清晰，便于后期维护。

6.2 可扩展性

新增图形类型时，仅需继承 Shape 并在 ShapeFactory 中注册即可，原有代码无需大规模修改。

6.3 性能与稳定性

程序基于 MFC 框架，利用系统消息机制驱动绘制流程，绘图响应及时，运行稳定。

七、总结与体会

通过本次项目的实现，加深了对 MFC 框架、GDI 绘图以及面向对象设计模式的理解。
在实际编码过程中，将课堂所学的抽象概念转化为可运行的工程代码，对软件架构设计与工程规范有了更加直观的认识。

本项目不仅完成了课程要求的功能目标，也为后续进一步学习 Windows 应用开发和软件工程实践奠定了良好基础。
